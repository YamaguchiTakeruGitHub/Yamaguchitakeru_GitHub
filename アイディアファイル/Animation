#pragma once
#include "AnimationManager.h"
#include "DxLib.h"

class Player
{
public:
    Player();
    void Init();
    void Update(float deltaTime);
    void Render();

private:
    VECTOR position;
    int modelHandle;

    AnimationManager animationManager;
    std::string currentAnimation;
};


#include "Player.h"

Player::Player()
    : position(VGet(0.0f, 0.0f, 0.0f)), modelHandle(-1), currentAnimation("Idle")
{
}

void Player::Init()
{
    modelHandle = MV1LoadModel("path/to/your/playerModel.mv1"); // モデルのロード

    // アニメーションの初期化
    animationManager.InitChangeAnimation("Player", modelHandle);
}

void Player::Update(float deltaTime)
{
    // プレイヤーの操作（例: キーボードやジョイパッドの入力）
    if (CheckHitKey(KEY_INPUT_W)) // 前進
    {
        position.z += 1.0f; // 例: 移動
        currentAnimation = "Run";
    }
    else if (CheckHitKey(KEY_INPUT_SPACE)) // 攻撃
    {
        currentAnimation = "Attack";
    }
    else
    {
        currentAnimation = "Idle";
    }

    // アニメーションの更新
    animationManager.ChangeAnimation("Player", currentAnimation);
    animationManager.Update(deltaTime);

    // モデルのアニメーション時間を更新
    MV1SetPosition(modelHandle, position);
}

void Player::Render()
{
    // モデルを描画
    MV1DrawModel(modelHandle);
}

Hpバーコード下

#pragma once
#include "DxLib.h"

class Player
{
public:
    Player();
    void Init();
    void Update(float deltaTime);
    void Render();

    // HP関連の関数
    void TakeDamage(int damage); // ダメージを受ける

private:
    VECTOR position;
    int modelHandle;

    // HP関連
    int maxHP;
    int currentHP;

    // HPバーのサイズや位置
    int hpBarWidth;
    int hpBarHeight;
    int hpBarPosX;
    int hpBarPosY;

    void DrawHPBar(); // HPバーの描画
};
#include "Player.h"

Player::Player()
    : position(VGet(0.0f, 0.0f, 0.0f)), modelHandle(-1), maxHP(100), currentHP(100),
      hpBarWidth(200), hpBarHeight(20), hpBarPosX(50), hpBarPosY(50)
{
}

void Player::Init()
{
    modelHandle = MV1LoadModel("path/to/your/playerModel.mv1");
}

void Player::Update(float deltaTime)
{
    // 例: ダメージを受けたとき
    if (CheckHitKey(KEY_INPUT_D))
    {
        TakeDamage(10); // ダメージを受ける
    }

    // プレイヤーの位置などを更新
    MV1SetPosition(modelHandle, position);
}

void Player::Render()
{
    // モデルの描画
    MV1DrawModel(modelHandle);

    // HPバーの描画
    DrawHPBar();
}

void Player::TakeDamage(int damage)
{
    currentHP -= damage;
    if (currentHP < 0)
    {
        currentHP = 0; // HPが0以下にならないように制限
    }
}

void Player::DrawHPBar()
{
    // HPバーのバックグラウンド（空のバー）
    DrawBox(hpBarPosX, hpBarPosY, hpBarPosX + hpBarWidth, hpBarPosY + hpBarHeight, GetColor(255, 0, 0), TRUE);

    // 現在のHPに応じたバーの長さを計算
    int currentBarWidth = static_cast<int>((float)currentHP / maxHP * hpBarWidth);

    // HPバーの前面（現在のHPを示すバー）
    DrawBox(hpBarPosX, hpBarPosY, hpBarPosX + currentBarWidth, hpBarPosY + hpBarHeight, GetColor(0, 255, 0), TRUE);
}




ロックオンの仕組み下

#include "DxLib.h"
#include <vector>

class Target
{
public:
    VECTOR position; // ターゲットの座標
    Target(VECTOR pos) : position(pos) {}
};

// プレイヤー周囲のターゲットを検出
Target* FindNearestTarget(VECTOR playerPosition, const std::vector<Target>& targets, float lockOnRange)
{
    Target* nearestTarget = nullptr;
    float nearestDistance = lockOnRange; // ロックオン可能な距離

    for (const auto& target : targets)
    {
        // プレイヤーとターゲットの距離を計算
        float distance = VSize(VSub(target.position, playerPosition));

        // ロックオン範囲内で最も近いターゲットを探す
        if (distance < nearestDistance)
        {
            nearestTarget = const_cast<Target*>(&target); // 最近接ターゲットを更新
            nearestDistance = distance;
        }
    }

    return nearestTarget; // 見つからなければ nullptr を返す
}




void LockOnToTarget(VECTOR& playerDirection, VECTOR playerPosition, VECTOR targetPosition)
{
    // ターゲットの方向を計算
    VECTOR directionToTarget = VSub(targetPosition, playerPosition);

    // 視線をターゲット方向に合わせる
    playerDirection = VNorm(directionToTarget); // 正規化して方向ベクトルにする
}



void UpdateCameraToLockOnTarget(VECTOR playerPosition, VECTOR targetPosition)
{
    // カメラのターゲット位置を設定
    SetCameraPositionAndTarget_UpVecY(VGet(playerPosition.x, playerPosition.y + 5.0f, playerPosition.z), targetPosition);
}



bool isLockedOn = false; // ロックオン状態を管理するフラグ

void HandleLockOnInput(Target*& lockedOnTarget, VECTOR playerPosition, const std::vector<Target>& targets)
{
    // ロックオンキーが押された場合
    if (CheckHitKey(KEY_INPUT_L))
    {
        if (isLockedOn)
        {
            // ロックオン解除
            lockedOnTarget = nullptr;
            isLockedOn = false;
        }
        else
        {
            // 最も近いターゲットを探してロックオン
            lockedOnTarget = FindNearestTarget(playerPosition, targets, 100.0f); // 例: 100.0fがロックオン距離
            if (lockedOnTarget)
            {
                isLockedOn = true;
            }
        }
    }

    // ターゲットがロックオンされている場合はカメラをターゲットに向ける
    if (isLockedOn && lockedOnTarget)
    {
        UpdateCameraToLockOnTarget(playerPosition, lockedOnTarget->position);
    }
}

